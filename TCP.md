# TCP 3-way handshake와 4-way handshake

## TCP

- **TCP (전송 제어 프로토콜)**은 두 개의 호스트를 연결하고 데이터 스트림을 교환하게 해주는 중요한 네트워크 프로토콜
- **연결 지향(connection-Oriented) 프로토콜**

## TCP의 작동

### 3-way handshake

TCP는 신뢰성 있는 통신을 위해 송신자, 수신자는 데이터를 전송하기 전 먼저 서로 통신이 가능한 지 의사를 묻고 한 번에 얼마나 받을 수 있는지 등의 정보 확인

```
1. 송신자가 수신자에게 ‘SYN’을 날러 통신이 가능한지 확인, 이 때 Port가 열려 있어야 함
2. 수신자가 송신자로부터 ‘SYN’를 받고 ‘SYN/ACK’을 송신자에게 날려 통신할 준비가 되어있음을 알림
3. 송신자가 수신자의 ‘SYN/ACK’을 받고 ‘ACK’를 날려 전송을 시작함을 알림 .
```
![image](https://github.com/do-sopt-cs-study/CS-Jihee/assets/68178395/2e9a33c8-a3f1-4a84-83db-b4e0eb338120)


- TCP로 이뤄지는 모든 통신은 3-way handshake를 통해 시작. 클라이언트가 받을 준비가 되었는지, 서버가 받을 준비가 되어 있는지를 미리 확인한 후 통신 시작 → 데이터 안전하게 보냄
- 통신이 잘 이뤄지면 ‘ACK’를 서버에게 알림
- 서버는 ‘ACK’를 보고 클라이언트가 데이터를 잘 받았음을 확인하고 다음 데이터를 전달할 준비를 함

### TCP 4 way handshake

논리적인 접속 상태를 해제하기 위해 필요한 과정, 이 과정을 통해 수신자, 송신자는 TCP 연결 해제, 연결을 위해 사용했던 리소스가 정리됨

- 송수신자가 모두 끝낼 준비를 마치고 통신이 종료되어야하기 때문에 4-way handshake

### flag

- SYN(연결 요청 flag)
- ACK(응답 flag)
- FIN(연결종료 flag)
- RST(연결 재설정 flag)
- PSH(밀어넣기)
- URG(긴급 데이터 flag)

```
1. 연결이 되어 있는 상태
2. 연결을 종료하고자 하는 클라이언트는 서버에게 tcp header 의 flags 필드의 FIN 을 1을 세팅하여 전송하고 소켓을 FIN_WAIT_1 상태로 변경
3. FIN 을 받은 서버는 CLOSE_WAIT 상태로 변경되며 FIN 에 대응 되는 ACK 를 전송해 줍니다. ACK 전송을 받은 클라이언트는 FIN_WAIT_2 상태로 변경되며 서버의 FIN을 받을 때까지 대기
4. 서버는 연결 종료를 위해 FIN 패킷을 클라이언트에게 전송하며 소켓을 LAST_ACK 상태로 변경
5. FIN을 받은 클라이언트는 TIME_WAIT 상태로 변경되며 FIN 에 대응되는 ACK 를 서버에 전송. ACK 를 받은 서버는 소켓을 CLOSED 상태로 변경.
6. 시간이 경과한 뒤, 클라이언트도 소켓을 CLOSED 상태로 변경. (MSL 은 커널마다 지정된 시간 확인필요)

```
![image](https://github.com/do-sopt-cs-study/CS-Jihee/assets/68178395/e580373e-d188-46b5-ab73-080689dada50)


# TCP/IP 흐름제어와 혼잡제어

## 흐름제어
송신측과 수신측의 데이터 처리 속도 차이를 해결하기 위한 기법 : 수신측이 송신측보다 데이터 처리 속도가 빠르면 문제없지만, 송신측의 속도가 빠를 경우 문제 발생
- 수신측에서 제한된 저장 용량을 초과한 이후에 도착하는 데이터 손실 가능성, 손실 시 불필요한 응답과 데이터 전송이 발생
- 위험을 줄이기 위해 receiver가 packet을 지나치게 많이 받지 않도록 조절
- 기본 개념은 receiver가 sender에게 현재 자신의 상태를 feedback 한다는 점
  
### 3-way handshaking에서
송신자는 자신이 한번에 얼마나 보낼 수 있는지, 수신자는 자신이 데이터를 어디까지 받았는지 끊임없이 확인하고 TCP Header 내의 ‘Window size”를 사용해 한번에 받고 보낼 수 있는 데이터의 양을 정함
window: 일정량의 데이터

window size: (3-way handshake 때) 자신의 상황에 따라 수신자가 정함

**Acknowledgment Number** : 수신자가 지금까지 받은 데이터 양을 확인하여 송신자에게 보냄

**Sequence Number** : 데이터의 순서 번호를 표기한 것

## 혼합제어

데이터를 주고받는 양 단말(Endpoint)도 중요하지만 데이터가 지나가는 네트워크망의 혼잡도 중요
- 송신측의 데이터 전달과 네트워크의 데이터 처리 속도 차이를 해결하기 위한 기법
- 
![image](https://github.com/do-sopt-cs-study/CS-Jihee/assets/68178395/4431a01d-2a33-4f2a-b92b-b7d80063d6aa)

### AIMD(Additive Increase / Multiplicative Decrease)
처음에 패킷을 하나씩 보내고 이것이 문제없이 도착하면 window 크기(단위 시간 내에 보내는 패킷의 수)를 1씩 증가시켜가며 전송하는 방법
- 패킷 전송에 실패하거나 일정 시간을 넘으면 패킷의 보내는 속도는 절반으로 감소됨
- 공평한 방식으로, 여러 호스트가 한 네트워크를 공유하고 있으면 나중에 진입하는 쪽이 처음에는 불리하지만, 시간이 흐르면 평형상태로 수렴하게 되는 특징
- 문제점은 초기에 네트워크의 높은 대역폭을 사용하지 못하여 오랜 시간이 걸리게 되고, 네트워크가 혼잡해지는 상황을 미리 감지 불가. 즉, 네트워크가 혼잡해지고 나서야 대역폭을 줄이는 방식

### ‘slow start’

- 연결 초기에 송신자와 수신자가 데이터를 넉넉히 주고받을 준비가 되어있더라고 중간 경로인 네트워크가 혼잡하면 통신이 제대로 안됨.
- 송신자가 연결 초기에 데이터 송출량을 낮게 잡고 보내면서 수신자의 수신을 확인하며 데이터 송출량을 조금씩 늘림
    → 즉, 현재 네트워크에 가장 적합한 데이터 송출량을 확인 가능

### Fast Retransmit (빠른 재전송)
빠른 재전송은 TCP의 혼잡 조절에 추가된 정책
- 패킷을 받는 쪽에서 먼저 도착해야할 패킷이 도착하지 않고 다음 패킷이 도착한 경우에도 ACK 패킷을 보내게 됨
- 단, 순서대로 잘 도착한 마지막 패킷의 다음 패킷의 순번을 ACK 패킷에 실어서 보내게 되므로, 중간에 하나가 손실되게 되면 송신 측에서는 순번이 중복된 ACK 패킷을 받게 됨 -> 이것을 감지하는 순간 문제가 되는 순번의 패킷을 재전송 가능
- 중복된 순번의 패킷을 3개 받으면 재전송. 약간 혼잡한 상황이 일어난 것이므로 혼잡을 감지하고 window size 축소
  
### Fast Recovery (빠른 회복)
- 혼잡한 상태가 되면 window size를 1로 줄이지 않고 반으로 줄이고 선형증가시키는 방법
- 이 정책까지 적용하면 혼잡 상황을 한번 겪고 나서부터는 순수한 AIMD 방식으로 동작
